package algorithms.maze3D;

import algorithms.mazeGenerators.Position;

import java.nio.file.DirectoryStream;
import java.util.*;

public class MyMaze3DGenerator extends AMaze3DGenerator {
    private Maze3D maze;
    private int depth_;
    private int row_;
    private int col_;
    private int[][][] map;
    private Random random;
    private ArrayList<int[]> DIRS;


    /**
     * this method generates a 3D maze using the binary tree algorithm.
     * @param depth : the depth of the maze
     * @param row : the number of rows in the maze
     * @param column : the number of columns in the maze
     * @return Maze3D that was generated by the algorithm
     */
    @Override
    public Maze3D generate(int depth, int row, int column) {
         int[][] D = {
                {1, 0, 0},
                {-1, 0, 0},
                {0, 1, 0},
                {0, 0, 1},
        };DIRS = new ArrayList<>();
        Collections.addAll(DIRS, D);
        random = new Random();
        depth_ = depth;
        row_ = row;
        col_ = column;
        maze = new Maze3D(depth, row, column);
        map = maze.getMap();
        binaryTree3D();
        return maze;
    }

    /**
     * This function generates a 3D maze using the binary tree algorithm
     * which marks a path from the start to the goal position.
     * It then randomly marks remaining cells as walls or passages.
     */
    private void binaryTree3D() {
        Position3D curr = maze.getStartPosition();
        Position3D goal = maze.getGoalPosition();
        while (!curr.equals(goal)) {
            map[curr.getDepth_index()][curr.getRow_index()][curr.getColumn_index()] = 2;
            Position3D curr2 = chooseNextPos(curr);
            if (curr2 == null) { // if we reached a dead end, start backing out
                curr2 = new Position3D(curr.getDepth_index()-1, curr.getRow_index(), curr.getColumn_index());
            }
            curr = curr2;
        }
        map[goal.getDepth_index()][goal.getRow_index()][goal.getColumn_index()] = 2;
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j <map[i].length ; j++) {
                for (int k = 0; k <map[i][j].length ; k++) {
                    if (map[i][j][k] != 2)
                        // If the cell is not part of the path, randomly mark it as a wall or a passage
                        map[i][j][k] = random.nextInt(2);
                    else
                        // If the cell is part of the path, mark it as a passage
                        map[i][j][k] = 0;
                }
            }
        }
    }

    /**
     * This method takes a 3D position object as an argument
     * And returns the next position object to move to randomly from his unvisited neighbors.
     * If no valid moves are available, it returns null.
     */
    private Position3D chooseNextPos(Position3D curr)
    {
        Collections.shuffle(DIRS);
        for(int index=0; index<4; index ++){
            int [] nextPos = new int[]{curr.getDepth_index() + DIRS.get(index)[0], curr.getRow_index() + DIRS.get(index)[1], curr.getColumn_index() + DIRS.get(index)[2]};
            if(nextPos[0] >= 0 && nextPos[0] < depth_ && nextPos[1] >= 0 && nextPos[1] < row_ && nextPos[2] >= 0 && nextPos[2] < col_ && map[nextPos[0]][nextPos[1]][nextPos[2]] != 2) {
                return new Position3D(nextPos[0], nextPos[1], nextPos[2]);
            }
        }
        return null;
    }
}
